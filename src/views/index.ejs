<!-- views/index.ejs -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Game </title>
    <style>

        /* Layer 1 bottom */
        body {
            background-color: black;
            margin: 0;
            padding: 0;

            /* Lowest background layer */
            background-image: url('/images/background_starfields/stars_background.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;

            flex-direction: column;
            justify-content: flex-end;

            overflow: hidden;
        }

        /* Layer 2 middle */
        .pinprick-stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background-image: url('/images/background_starfields/star_field1.png');
            background-repeat: repeat;
            /*background-size: contain;*/
            z-index: 20;
        }

        /* Layer 3 top */
        .asteroid-field {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background-image: url('/images/asteroid_fields/asteroid_field1.png');
            background-repeat: repeat;
            background-size: 15%; /* Adjust this value to shrink the base image */
            z-index: 50;
        }

        /* Ship planets and main layer. */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 3200px;
            height: 1800px;
            /* may have to hardocde size here?*/
            border: 1px solid black;
            z-index: 70;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 3200px;
            height: 1800px;
            /* may have to hardocde size here?*/
            background: transparent;
            cursor: move;
            z-index: 100;
            /*pointer-events: auto; !* Allow pointer events *!*/
        }

        .toolbar {
            width: 14%;
            height: 90%;
            background-color: #add8e6; /* Pale blue background */
            border: 5px solid black; /* Thick black border */
            padding: 10px;
            box-sizing: border-box;
            position: fixed;
            bottom: 10px;
            right: 3%;
            /*display: flex;*/
            justify-content: space-between; /* Adjusted to space-between */
            z-index: 120; /* Ensure it is above other elements */
        }

        .stats {
            /*display: flex;*/
            gap: 20px;
        }

        .stat {
            font-size: 18px;
        }
    </style>
</head>
<body>

<div class="pinprick-stars" id="pinprick_stars"></div>

<div class="asteroid-field" id="asteroidfield"></div>

<canvas class="canvas" id="gridCanvas" width="3200" height="1800"></canvas>

<div class="overlay" id="overlay"></div>

<script>
  const canvas = document.getElementById('gridCanvas');
  const overlay = document.getElementById('overlay');

  const ctx = canvas.getContext('2d');
  const cellSize = 50;
  const cellHeight = cellSize;
  const cellWidth = cellSize;

  // const gridWidth = 30;
  // const gridHeight = 30;
  const gridWidth = <%= gridWidth %>;
  const gridHeight = <%= gridHeight %>;
  let players;
  let units;
  let gridOwners;

  let selectedShipId = null;
  let selectedShip = null;

  let zoom = 1
  const zoomFactor = 1.01
  let initialPinchDistance = null;




  // Render units
  units = <%- JSON.stringify(units) %>;

  // TODO need to save map to file. and load.

  // Draw ship on canvas now, rotate to face target, and path line, and selected yellow circle.
  function drawShip(ctx, ship) {
    // console.log("DEBUG1: drawing unit now at ", col, row, text);

    const x = ship.x * cellSize;
    const y = ship.y * cellSize;
    // console.log("DEBUG2: Unit x y now at ", x, y, text+ " size = ", size);

    // Show owner name.
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ship.playerName, x + cellSize / 2, y);

    // Add a yellow circle around it if it is selected.
    if (ship.id === selectedShipId) {
      ctx.beginPath();
      ctx.arc(x + cellSize / 2 + 10, y + cellSize / 2 + 5, cellSize, 0, 2 * Math.PI);
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    drawShipPath(ctx, ship, x, y);
    drawShipImage(ctx, ship, x, y);
  }

  function drawShipPath(ctx, ship, x, y) {
    // Draw a tracer line showing movement.
    ship.angle = 0; // DEBUG DEFAULT REMOVE LATER.
    if (ship.gotoX == null) {
      return;
    }

    ctx.beginPath();
    ctx.moveTo(x + cellSize / 2, y + cellSize / 2);
    ctx.lineTo(ship.gotoX * cellSize + cellSize / 2, ship.gotoY * cellSize + cellSize / 2);
    ctx.setLineDash([5, 5]); // Set dashed line pattern
    ctx.strokeStyle = 'grey'; // Set line color to grey
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.setLineDash([]); // Reset to solid line


    // Set direction angle for ship now.
    const dx = ship.gotoX - ship.x;
    const dy = ship.gotoY - ship.y;
    const angle = Math.atan2(dy, dx);
    ship.angle = angle;
  }

  function drawShipImage(ctx, ship, x, y) {
    // Add in our ship graphic now.
    // todo make multiple ship types usable.
    // TODO make simple method.
    const img = new Image();
    img.src = '/images/ships/' + ship.type + '.png';
    img.onload = function () {
      const imgWidth = 128;
      const imgHeight = 128;

      // Rotate ship to this angle.
      // Save the current context state
      ctx.save();
      ctx.scale(zoom, zoom); // Apply the scale transformation

      // Move the origin to the center of the image
      // ctx.translate(x + imgWidth / 2, y + imgHeight / 2);
      ctx.translate(x + cellSize / 2, y + cellSize / 2);

      // NOTE: Orig ship points SW at start, adjust for that.
      // Rotate the context to the desired angle
      // Add 180 + 45
      // TODO start all ship images pointing to 0
      ctx.rotate(ship.angle + (Math.PI / 8) * 10);

      // Draw the image, offsetting by half the image size to center it
      ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);

      // Restore the context to its original state
      ctx.restore();
    };
  }


  // Draws our graph paper lines now.
  function drawGrid(ctx, cellSize) {
    const width = canvas.width;
    const height = canvas.height;

    ctx.strokeStyle = 'gray'; // Color of the grid lines
    ctx.lineWidth = 1; // Width of the grid lines
    ctx.font = '12px Arial';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Draw vertical lines and numbers
    for (let x = 0; x <= width; x += cellSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();

      for (let y = 0; y <= height; y += cellSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();

        // Draw the cell number
        const col = x / cellSize;
        const row = y / cellSize;
        if (col % 5 === 0 && row % 5 === 0) {
          ctx.fillText(`${col},${row}`, x + cellSize / 2, y + cellSize / 2);
        }
      }
    }
  }

  function drawStar(ctx, cellSize) {
    const centerX = (gridWidth / 2) * cellSize;
    const centerY = (gridHeight / 2) * cellSize;
    const radius = (cellSize * 5) / 2;

    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    ctx.fillStyle = 'yellow';
    ctx.fill();
    ctx.strokeStyle = 'orange';
    ctx.lineWidth = 5;
    ctx.stroke();
  }

  function drawOrbit(ctx, cellSize, dist) {
    const centerX = (gridWidth / 2) * cellSize;
    const centerY = (gridHeight / 2) * cellSize;
    const radiusX = dist * cellSize;
    const radiusY = (dist * cellSize) * 0.6; // Slightly oval shape

    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  async function fetchUpdates() {
    const response = await fetch('/fetch-updates');
    const updates = await response.json();
    // console.log("DEBUG: updates = ", updates);

    return updates;
  }

  function drawShips(units) {
    units.forEach(unit => {
      drawShip(ctx, unit);
    });
  }

  function updateToolbar() {
    let troopCnt = 0;
    let totalTroops = 0;
    // Init an array for all players
    let troopTotals = [];
    units.forEach(unit => {
      totalTroops++;
      if (unit.playerId === players[0].id) {
        troopCnt++;
      }
      if (!troopTotals[unit.playerId]) { // init if not used.
        troopTotals[unit.playerId] = 0;
      }
      troopTotals[unit.playerId]++;
    });
    console.log("DEBUG: troopTotals = ", troopTotals);
    let enemyTroops = totalTroops - troopCnt;
    document.querySelector('.player-info').textContent = players[0].name;
    document.querySelector('#stat-troops').textContent = `Troops: ${troopCnt}`;
    document.querySelector('#stat-enemy-troops').textContent = `Enemy Troops: ${enemyTroops}`;
    document.querySelector('#stat-map-captured').textContent = `Map Captured: ${players[0].mapCapturePercent}%`;
    const gold = 26; // TEMP.
    document.querySelector('#stat-gold').textContent = `Gold: ${gold}`;
    // Other armies here:
    // Loop over players and display their stats.
    let troopTotalsText = '';
    for (let player of players) {
      if (player.id !== players[0].id) {
        troopTotalsText += `Player ${player.id} Troops: ${troopTotals[player.id]} <br>`;
      }
    }
    document.querySelector('#other-troops').innerHTML = troopTotalsText;
  }

  function findClosestShip(col, row) {
    let closestShip = null;
    let closestDist = 999999;
    units.forEach(unit => {
      // if (unit.type === 'ship') {
      // NOTE: Could get slow here.
      const dist = Math.sqrt((unit.x - col) ** 2 + (unit.y - row) ** 2);
      // console.log("DEBUG: checking nearest dist = ", dist, " and name = ", unit.name);
      if (dist < closestDist) {
        closestDist = dist;
        closestShip = unit;
      }
      // }
    });

    return closestShip;
  }

  // See if nearby, and return the ship.
  function shipClickedOn(col, row) {
    // Find nearest ship and see if close enough to click.
    const clickedShip = findClosestShip(col, row);
    // console.log("DEBUG: clickedShip = ", clickedShip);

    if (clickedShip) {
      const dist = Math.sqrt((clickedShip.x - col) ** 2 + (clickedShip.y - row) ** 2);
      if (dist > 1.5) {
        // console.log("DEBUG: too far away to click ship.");
        return;
      } else {
        console.log("DEBUG: *** Clicked ship is close enough to select. ship = ", clickedShip);
        return clickedShip;
      }
    }
  }


  // Add a listener for clicking on the map or ships or planets.
  // This will allow us to select a ship or planet or something.

  // START CHECK CANVAS LISTENERS.
  // canvas.addEventListener('click', (event) => {
  //   const rect = canvas.getBoundingClientRect();
  //   const x = event.clientX - rect.left;
  //   const y = event.clientY - rect.top;
  //
  //   console.log(`Canvas clicked at: (${x}, ${y})`);
  //
  //   // TODO Convert to grid coordinates.
  //
  //   // TODO See if a ship is clicked,
  //
  //   // TODO See if a planet or object is clicked.
  // });
  // END CHECK CANVAS LISTENERS.

  // On Click grid listener.
  overlay.addEventListener('click', function (event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    const col = Math.floor(x / cellSize);
    const row = Math.floor(y / cellSize);

    console.log(`\nClicked map: (${col}, ${row}) `);

    // Select or deselect a ship if clicked on.
    const clickedShip = shipClickedOn(col, row);
    // Set selected and redraw with a halo.
    if (!clickedShip || selectedShipId === clickedShip.id) {
      selectedShipId = null;
      selectedShip = null;
      // todo redraw toolbar
    } else {
      selectedShipId = clickedShip.id;
      selectedShip = clickedShip;
      // todo redraw toolbar
    }
    // TODO trigger redraw probably.

  });

  // START OVERLAY DRAG CODE.
  // And ship drag move code.
  let isDragging = false; // dragging for whole map.
  let isDraggingShip = false;
  let startX, startY;

  overlay.addEventListener('mousedown', (e) => {
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;

    // TODO see if we are on a ship, then drag it around instead.
    let rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const col = Math.floor(x / cellSize);
    const row = Math.floor(y / cellSize);
    const clickedShip = shipClickedOn(col, row);
    if (clickedShip) {
      console.log("DEBUG: dragging ship = ", clickedShip);
      // Move the ship.
      // clickedShip.x += dx / cellSize;
      // clickedShip.y += dy / cellSize;
      // console.log("DEBUG: dragged ship = ", clickedShip);

      selectedShipId = clickedShip.id;
      selectedShip = clickedShip;

      // TODO on drag drop if ship send to server now.

      isDraggingShip = true;
    }

  });

  // Allow dragging of full map here.
  overlay.addEventListener('mousemove', (e) => {
    if (!isDragging && !isDraggingShip) {
      return;
    }

    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    // console.log(`Dragging: dx = ${dx}, dy = ${dy}`);

    // Perform your movement logic here
    startX = e.clientX;
    startY = e.clientY;


    // Slide ship to new spot if needed.
    // TODO
    if (isDraggingShip) {
      // console.log("DEBUG: dragging ship = ", selectedShipId);

      // Draw a line where path will go.
      return;
    }

    // Slide around asteroid layer.
    const asteroidField = document.getElementById('asteroidfield');
    if (!asteroidField) {
      console.log("ERROR: asteroidField not found.");
      // return;
    }
    let rect = asteroidField.getBoundingClientRect();
    let currentX = rect.left + window.scrollX;
    let currentY = rect.top + window.scrollY;
    asteroidField.style.transform = `translate(${currentX + dx * 0.3}px, ${currentY + dy * 0.3}px)`;


    // Slide around ship layer a lot.
    const gridCanvas = document.getElementById('gridCanvas');
    if (!gridCanvas) {
      console.log("ERROR: gridCanvas not found.");
      // return;
    }
    rect = gridCanvas.getBoundingClientRect();
    currentX = rect.left + window.scrollX;
    currentY = rect.top + window.scrollY;
    gridCanvas.style.transform = `translate(${currentX + dx * 1}px, ${currentY + dy * 1}px)`;

    // Slide around pinpricks layer less.
    const pinprick_stars = document.getElementById('pinprick_stars');
    if (!pinprick_stars) {
      console.log("ERROR: pinprick_stars not found.");
      // return;
    }
    rect = pinprick_stars.getBoundingClientRect();
    currentX = rect.left + window.scrollX;
    currentY = rect.top + window.scrollY;
    pinprick_stars.style.transform = `translate(${currentX + dx * 0.03}px, ${currentY + dy * 0.03}px)`;
  });

  overlay.addEventListener('mouseup', (e) => {
    isDragging = false;

    if (isDraggingShip) {
      isDraggingShip = false;

      // Send ship update to server.
      // console.log("DEBUG: dragged ship  ");
      // New goto location is what.
      let rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // console.log("DEBUG: dragged ship to x y = ", x, y);
      const col = Math.floor(x / cellSize);
      const row = Math.floor(y / cellSize);
      console.log("DEBUG: dragged ship to col row = ", col, row);

      // Check distance is > 1.5 or ship not really dragged.
      const dist = Math.sqrt((selectedShip.x - (x / cellSize)) ** 2 + (selectedShip.y - (y / cellSize)) ** 2);
      if (dist < 1) {
        // console.log("DEBUG: dragged ship not far enough to move.");
        return;
      }

      selectedShip.gotoX = col;
      selectedShip.gotoY = row;

      // Pass new value back to server.
      fetch('/ship-new-goto', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          shipId: selectedShip.id,  // Ship ID
          x: col,  // New X
          y: row,  // New Y
        }),
      });
      // TODO make this secure, encrypt or key or such.
    }


    // TODO send ship update to server if moved!

    // Re-enable pointer events
    // overlay.style.pointerEvents = 'auto';
  });

  overlay.addEventListener('mouseleave', () => {
    isDragging = false;
    isDraggingShip = false;

    // Re-enable pointer events
    // overlay.style.pointerEvents = 'auto';
  });
  // END OVERLAY

  // Mouse wheel zooming.  TODO test
  overlay.addEventListener('wheel', (event) => {
    event.preventDefault();
    console.log("DEBUG: wheel zoom event = ", event);

    if (event.deltaY < 0) {
      // Zoom in
      zoom *= zoomFactor;
    } else {
      // Zoom out
      zoom /= zoomFactor;
    }
    console.log("DEBUG: zoom = ", zoom);

    // Bounds limits.
    if (zoom < 0.3) {
      zoom = 0.3;
    } else if (zoom > 2) {
      zoom = 2;
    }

    // Adjust the size of the asteroid field
    // const asteroidField = document.getElementById('asteroidfield');
    // if (asteroidField) {
    //   asteroidField.style.transform = `scale(${zoom})`;
    // }
    // // not centered.
    //
    // // Adjust the size of the pinprick stars
    // const pinprickStars = document.getElementById('pinprick_stars');
    // if (pinprickStars) {
    //   pinprickStars.style.transform = `scale(${zoom})`;  // not working?
    // }

    drawGameMap(units);
  });


  function drawGameMap(units) {
    ctx.save(); // Save the current context state

    // TODO make Draw System method instead.
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
    // TODO doesnt center on mouse point, and doesnt shrink backgrounds slightly.
    ctx.scale(zoom, zoom); // Apply the scale transformation

    drawStar(ctx, cellSize); // Draw the star at the center

    // TODO make draw Planets method next.
    drawOrbit(ctx, cellSize, 8); // Draw the orbit around the star
    drawOrbit(ctx, cellSize, 16); // Draw the orbit around the star
    drawOrbit(ctx, cellSize, 20); // Draw the orbit around the star
    drawOrbit(ctx, cellSize, 24); // Draw the orbit around the star
    drawOrbit(ctx, cellSize, 28); // Draw the orbit around the star
    // Max of 28 to fix map.
    // At least 4 apart to fit a planet.
    // Supports 5-6 planets in the area.

    // Debug stuffs draw grid.
    drawGrid(ctx, cellSize);

    drawShips(units);
    ctx.restore(); // Restore the context state
  }


  const gameSpeed = 3; // seconds
  setInterval(async () => {
    const updates = await fetchUpdates();
    units = updates.units;
    players = updates.players;
    // gridOwners = updates.gridOwners;

    drawGameMap(updates.units);

    // updateToolbar();
    // console.log("Updated units. ")

  }, 400 * gameSpeed);
</script>

<div class="toolbar">
    <!-- Toolbar content goes here -->
    <div class="player-info">Player Name<br></div>
    <div class="stats">
        <div class="stat" id="stat-troops">Troops: 10<br></div>
        <div class="stat" id="stat-enemy-troops">Enemy Troops: 8<br></div>
        <div class="stat" id="stat-map-captured">Map Captured: 50%<br></div>
        <div class="stat" id="stat-gold">Gold: 100<br></div>
        <div class="stat" id="other-troops">Player 2 Troops: 5<br>Player 3 Troops: 3<br>Player 4 Troops: 2<br></div>
    </div>

    <img src="/images/aliens/silver_aliens.png" alt="Aliens" style="width: 100%;">
</div>

</body>
</html>